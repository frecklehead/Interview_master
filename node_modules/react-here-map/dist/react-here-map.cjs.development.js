'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var merge = _interopDefault(require('lodash.merge'));
var dotProp = require('dot-prop');
var hereMapJS = _interopDefault(require('@limistah/here-map-js'));

/**
 * @type {string} Default version for the API
 */
const VERSION = 'v3/3.1';
const mapTypes = ['raster.normal.map', 'raster.normal.xbase', 'raster.normal.xbasenight', 'raster.normal.basen', 'raster.normal.basenight', 'raster.normal.mapnight', 'raster.normal.traffic', 'raster.normal.trafficnight', 'raster.normal.transit', 'raster.normal.panoram', 'raster.normal.panoramnight', 'raster.normal.labels', 'raster.normal.metaInfo', 'raster.satellite.xbase', 'raster.satellite.base', 'raster.satellite.map', 'raster.satellite.traffic', 'raster.satellite.panorama', 'raster.satellite.labels', 'raster.terrain.xbase', 'raster.terrain.base', 'raster.terrain.map', 'raster.terrain.traffic', 'raster.terrain.panorama', 'raster.terrain.labels', 'raster.incidents', 'raster.venues', 'vector.normal.map', 'vector.normal.xbase', 'vector.normal.xbasenight', 'vector.normal.basen', 'vector.normal.basenight', 'vector.normal.mapnight', 'vector.normal.traffic', 'vector.normal.trafficnight', 'vector.normal.transit', 'vector.normal.panoram', 'vector.normal.panoramnight', 'vector.normal.labels', 'vector.normal.metaInfo', 'vector.satellite.xbase', 'vector.satellite.base', 'vector.satellite.map', 'vector.satellite.traffic', 'vector.satellite.panorama', 'vector.satellite.labels', 'vector.terrain.xbase', 'vector.terrain.base', 'vector.terrain.map', 'vector.terrain.traffic', 'vector.terrain.panorama', 'vector.terrain.labels', 'vector.incidents', 'vector.venues'];
const MAP_TYPE = 'vector.normal.map';
const mapOptions = {
  zoom: 8,
  center: {
    lat: 6.5243793,
    lng: 3.3792057
  },
  mapType: MAP_TYPE
};
const useEvents = false;
const interactive = false;
const includeUI = false;
const containerId = 'HERE_MAP_CONTAINER';
const defaultClassName = 'here-map-container';
const includePlaces = false;
// Function that does really nothing, still it is a function, and has its right!
const noop = () => {};
const mapEvents = {
  pointercancel: noop,
  drag: noop,
  dragend: noop,
  tab: noop,
  dbltap: noop,
  pointerdown: noop,
  pointerenter: noop,
  pointerleave: noop,
  pointermove: noop,
  pointerup: noop,
  dragstart: noop
};
const defaultOptions = {
  VERSION,
  mapEvents,
  MAP_TYPE,
  mapTypes,
  mapOptions,
  interactive,
  includeUI,
  includePlaces,
  useEvents,
  containerId,
  defaultClassName,
  app_id: '',
  app_code: '',
  apikey: ''
};

// provider a provider
// create a hook for the platform context
const PlatformContext = /*#__PURE__*/React.createContext({
  platform: null
});

// provider a provider
// create a hook for the platform context
const MapContext = /*#__PURE__*/React.createContext({
  map: null,
  ui: null,
  interaction: null
});

const validateMapType = mapType => {
  if (!mapTypes.includes(mapType)) {
    throw new Error('mapType Should be one from https://developer.here.com/documentation/maps/topics/map-types.html in dot notation');
  }
};

const initInteractionStyles = () => {
  const style = document.createElement('style');
  const css = `.grab = {cursor: move;cursor: grab;cursor: -moz-grab;cursor: -webkit-grab;}.grabbing{cursor:grabbing;cursor:-moz-grabbing;cursor:-webkit-grabbing}`;
  style.type = 'text/css';
  style.appendChild(document.createTextNode(css));
  const head = document.head || document.getElementsByTagName('head')[0];
  head.appendChild(style);
};

// import initInteraction from './initInteraction';
const initMap = (container, mapLayer, mapOptions) => {
  // Instantiate (and display) a map object:
  const map = container.current ? new H.Map(container.current, mapLayer, mapOptions) : null;
  map === null || map === void 0 ? void 0 : map.setCenter(mapOptions.center);
  return map;
};
const initInteraction = (map, interactive, useEvents, events) => {
  const behavior = interactive && map ? new H.mapevents.Behavior(new H.mapevents.MapEvents(map)) : null;
  if (useEvents && interactive && map) {
    for (const type in events) {
      if (events.hasOwnProperty(type)) {
        const callback = events[type];
        if (callback && typeof callback === 'function') {
          map.addEventListener(type, callback);
        }
      }
    }
  }
  return behavior;
};
const initDefaultUI = (platform, map, includeUI, uiLang) => {
  if (!includeUI) {
    throw new Error('includeUI must be set to true to initialize default UI');
  }
  // Create the default UI components
  return H.ui.UI.createDefault(map, platform.createDefaultLayers(), uiLang);
};
const buildMap = (platform, options) => {
  // Get values from the options
  const {
    useEvents,
    mapEvents,
    interactive,
    includeUI,
    mapOptions,
    uiLang,
    container,
    build
  } = options;
  const retObject = {
    map: null,
    interaction: null,
    ui: null,
    options: {
      ...options,
      mapType: mapOptions.mapType || 'vector.normal.map'
    }
  };
  if (container && build && retObject.options) {
    validateMapType(retObject.options.mapType);
    // Get all the default layers so we can set which to use based on the map type
    const defaultLayers = platform.createDefaultLayers();
    const mapLayer = dotProp.getProperty(defaultLayers, retObject.options.mapType);
    // Create a Map
    retObject.map = mapLayer ? initMap(container, mapLayer, mapOptions) : null;
    while (interactive && !retObject.interaction) {
      retObject.interaction = initInteraction(retObject.map, interactive, useEvents, mapEvents);
      if (includeUI) {
        retObject.ui = initDefaultUI(platform, retObject.map, includeUI, uiLang);
      }
      // Adds the grabbing to the document
      initInteractionStyles();
    }
  }
  return retObject;
};

const HMap = props => {
  // props.options?.center
  // const Platform = useHPlatform()
  const platformState = React.useContext(PlatformContext);
  const [mapState, setMapState] = React.useState({
    map: null,
    ui: null,
    options: undefined,
    interaction: null
  });
  const containerRef = props.ref || React.useRef(null);
  React.useEffect(() => {
    var _platformState$option;
    const mergedOptions = merge({
      container: containerRef,
      build: true
    }, platformState.options, {
      mapOptions: {
        ...((_platformState$option = platformState.options) === null || _platformState$option === void 0 ? void 0 : _platformState$option.mapOptions),
        ...props.options
      }
    }, {
      interactive: props.interactive,
      useEvents: props.useEvents
    });
    const buildResult = buildMap(platformState.platform, mergedOptions);
    setMapState(buildResult);
  }, []);
  const {
    style,
    loadingEl,
    children
  } = props;
  // const { options } = this.state.builder;
  const options = {};
  const LoadingComponent = () => {
    return React__default.createElement("div", null, "Loading");
  };
  const loading = loadingEl || React__default.createElement(LoadingComponent, null);
  return (
    // only render map provider when there is a platform state
    platformState.platform && React__default.createElement(MapContext.Provider, {
      value: mapState
    }, React__default.createElement("div", {
      id: defaultOptions.containerId,
      className: defaultOptions.defaultClassName,
      style: style,
      ref: containerRef
    }, typeof H === 'undefined' && !options && loading, typeof H === 'object' && mapState.map && options && children))
  );
};

const initMapObjectEvents = (mapObject, objectEvents, platformOptions) => {
  const {
    useEvents,
    interactive
  } = platformOptions;
  console.log(objectEvents);
  if (useEvents && interactive && objectEvents) {
    for (const type in objectEvents) {
      if (objectEvents.hasOwnProperty(type)) {
        const callback = objectEvents[type];
        if (callback && typeof callback === 'function') {
          mapObject.addEventListener(type, callback);
        }
      }
    }
  }
};

const BaseMapObject = _ref => {
  let {
    initializeFn,
    initializeDeps,
    events,
    zoom
  } = _ref;
  const mapContext = React.useContext(MapContext);
  if (!mapContext.map) {
    throw new Error('A map Object must be a child of HMap');
  }
  React.useEffect(() => {
    var _mapContext$map, _mapContext$map2, _mapContext$map3;
    const object = initializeFn(mapContext);
    mapContext === null || mapContext === void 0 ? void 0 : (_mapContext$map = mapContext.map) === null || _mapContext$map === void 0 ? void 0 : _mapContext$map.getViewModel().setLookAtData({
      bounds: object.getGeometry()
    });
    (_mapContext$map2 = mapContext.map) === null || _mapContext$map2 === void 0 ? void 0 : _mapContext$map2.setZoom(zoom || 4);
    // Add event listener to the object if intention of using the object is defined
    const {
      useEvents,
      interactive
    } = mapContext.options || {};
    initMapObjectEvents(object, events, {
      interactive: Boolean(interactive),
      useEvents: Boolean(useEvents)
    });
    (_mapContext$map3 = mapContext.map) === null || _mapContext$map3 === void 0 ? void 0 : _mapContext$map3.addObject(object);
  }, [initializeDeps]);
  return null;
};

const HMapPolyline = props => {
  if (!Array.isArray(props.points)) {
    throw new Error('points should be an array of objects containing lat and lng properties');
  }
  const initFn = React.useCallback(() => {
    const {
      points,
      options
    } = props;
    // Initialize a LineString and add all the points to it:
    const lineString = new H.geo.LineString();
    points.forEach(function (point) {
      lineString.pushPoint(point);
    });
    // Initialize a polyLine with the lineString:
    return new H.map.Polyline(lineString, options);
  }, [props.points]);
  return React__default.createElement(BaseMapObject, {
    initializeDeps: props.points,
    initializeFn: initFn,
    events: props.events
  });
};

const HMapRectangle = props => {
  if (!Array.isArray(props.points)) {
    throw new Error('points should be an array of objects containing lat and lng properties');
  }
  const initFn = React.useCallback(() => {
    const {
      points,
      options
    } = props;
    // Get a bounding box
    const boundingBox = new H.geo.Rect(points[0], points[1], points[2], points[3]);
    // Initialize a LineString and add all the points to it:
    return new H.map.Rect(boundingBox, options);
  }, [props.points]);
  return React__default.createElement(BaseMapObject, {
    initializeDeps: props.points,
    initializeFn: initFn,
    events: props.events
  });
};

const HMapPolygon = props => {
  if (!Array.isArray(props.points)) {
    throw new Error('points should be an array of objects containing lat and lng properties');
  }
  const initFn = React.useCallback(() => {
    const {
      points,
      options
    } = props;
    let lineString;
    const firstEl = points[0];
    if (typeof firstEl === 'string' && firstEl.split(',').length === 2) {
      lineString = new H.geo.LineString();
      const p = points;
      p.forEach(function (coords) {
        const c = coords.split(',').map(c => Number(c));
        // c has to be lat, lng, alt
        lineString.pushLatLngAlt.apply(lineString, [c[0], c[1], c[2]]);
      });
    } else {
      lineString = new H.geo.LineString(points);
    }
    // Initialize a LineString and add all the points to it:
    return new H.map.Polygon(lineString, options);
  }, [props.points]);
  return React__default.createElement(BaseMapObject, {
    initializeDeps: props.points,
    initializeFn: initFn,
    events: props.events
  });
};

const HMapMarker = props => {
  if (!props.coords.lng || !props.coords.lat) {
    throw new Error("coords should be an object having 'lat' and 'lng' as props");
  }
  const initFn = React.useCallback(() => {
    const {
      coords,
      options,
      icon
    } = props;
    const _options = {
      ...options
    };
    if (icon) _options.icon = new H.map.Icon(icon);
    return new H.map.Marker(coords, _options);
  }, [props.coords]);
  return React__default.createElement(BaseMapObject, {
    initializeDeps: props.coords,
    initializeFn: initFn,
    events: props.events
  });
};

const HMapCircle = props => {
  const {
    coords,
    options,
    radius,
    events,
    zoom
  } = props;
  if (!coords.lng || !coords.lat) {
    throw new Error("coords should be an object having 'lat' and 'lng' as props");
  }
  if (!props.radius) {
    console.info('radius is not set, default radius of 1000 is used');
  }
  const initFn = React.useCallback(() => {
    const circle = new H.map.Circle(coords, radius || 1000, options);
    return circle;
  }, [coords]);
  return React__default.createElement(BaseMapObject, {
    initializeDeps: coords,
    initializeFn: initFn,
    events: events,
    zoom: zoom
  });
};

const HMapLayer = props => {
  const {
    type
  } = props;
  const mapContext = React.useContext(MapContext);
  const platformContext = React.useContext(PlatformContext);
  if (!mapContext.map) {
    throw new Error('A map Object must be a child of HMap');
  }
  validateMapType(type);
  React.useEffect(() => {
    var _platformContext$plat;
    const defaultLayers = (_platformContext$plat = platformContext.platform) === null || _platformContext$plat === void 0 ? void 0 : _platformContext$plat.createDefaultLayers();
    const mapLayer = dotProp.getProperty(defaultLayers, type);
    if (mapLayer) {
      var _mapContext$map;
      (_mapContext$map = mapContext.map) === null || _mapContext$map === void 0 ? void 0 : _mapContext$map.addLayer(mapLayer);
    } else {
      console.error(type, ' is not supported as a layer.');
    }
  }, [type]);
  return null;
};

// Merges the option with the defaults to create a unison and make required values available
const optionMerger = options => {
  const {
    appId,
    appCode,
    apiKey,
    ...opts
  } = options;
  return merge(defaultOptions, {
    ...opts,
    app_id: appId,
    app_code: appCode,
    apikey: apiKey
  });
};
const loadHMap = async function (options) {
  if (options === void 0) {
    options = {
      includePlaces: false,
      includeUI: false,
      interactive: false,
      version: 'v3/3.1'
    };
  }
  const mergedOptions = optionMerger(options);
  const {
    VERSION,
    version,
    interactive,
    includeUI
  } = mergedOptions;
  // Returns async loading of the component
  // First load the core, to save us reference error if all of the libraries are loaded asynchronously due to race conditions
  return hereMapJS({
    includeUI,
    includePlaces: false,
    interactive,
    version: version || VERSION
  }).then(() => mergedOptions);
};

const initHPlatform = options => {
  const {
    app_id,
    app_code,
    apikey
  } = options || {};
  if ((!app_id || !app_code) && !apikey) {
    throw new Error('Options must include appId and appCode OR an apiKey');
  }
  // @ts-ignore
  const h = window.H;
  if (typeof h === 'undefined' || !h.service) {
    throw new Error('Here Map JavaScript files are not loaded.');
  }
  return new h.service.Platform({
    apikey: String(apikey)
  });
};

const HPlatform = props => {
  // Reload the map resources if the options changes
  React.useEffect(() => {
    loadHMap(props.options).then(options => {
      setPlatformState({
        ...platformState,
        options
      });
    });
  }, [props.options]);
  const initilizePlatform = () => {
    const platform = initHPlatform(platformState.options);
    setPlatformState(prevState => ({
      ...prevState,
      platform
    }));
  };
  const [platformState, setPlatformState] = React.useState({
    reInitMap: initilizePlatform,
    platform: null
  });
  React.useEffect(() => {
    // initialize the platform when the js files are loaded the options are updated
    platformState.options && initilizePlatform();
  }, [platformState.options]);
  const {
    platform,
    options
  } = platformState;
  return React__default.createElement(PlatformContext.Provider, {
    value: platformState
  }, typeof (platform === null || platform === void 0 ? void 0 : platform.setBaseUrl) == 'function' && ((options === null || options === void 0 ? void 0 : options.app_code) || (options === null || options === void 0 ? void 0 : options.apikey)) && props.children);
};
// Use this to create A Here Map Platform
const useHPlatform = (platformOptions, children) => React__default.createElement(HPlatform, {
  options: platformOptions
}, children);

exports.HMap = HMap;
exports.HMapCircle = HMapCircle;
exports.HMapLayer = HMapLayer;
exports.HMapMarker = HMapMarker;
exports.HMapPolygon = HMapPolygon;
exports.HMapPolyline = HMapPolyline;
exports.HMapRectangle = HMapRectangle;
exports.HPlatform = HPlatform;
exports.useHPlatform = useHPlatform;
//# sourceMappingURL=react-here-map.cjs.development.js.map
